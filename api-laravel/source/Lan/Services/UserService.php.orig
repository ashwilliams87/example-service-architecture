<?php

namespace Lan\Services;

use Ice\Exception\Security_User_NotFound;
use Lan\DataTypes\Contracts\Http\RequestResult\StatusInterface;
use Lan\DataTypes\EbsCarbon;
use Lan\DataTypes\Http\RequestResult\Error\CustomError;
use Lan\DataTypes\Http\RequestResult\Error\LogIn\AccountNotFoundError;
use Lan\DataTypes\Http\RequestResult\Error\LogOut\LogOutError;
use Lan\DataTypes\Http\RequestResult\Success\GenericSuccessResult;
use Lan\DTOs\Auth\LogInResultDTO;
use Lan\DTOs\Auth\Requests\LoginRequestDTO;
use Lan\DTOs\Auth\Requests\RecoverPasswordRequestDTO;
use Lan\DTOs\Auth\Responses\UserResponseDTO;
use Lan\Repositories\Contracts\UserRepositoryInterface;
use Lan\Services\Contracts\Security\SecurityServiceInterface;
use Lan\Services\Contracts\UserServiceInterface;
use Lan\DataTypes\Http\RequestResult\Error\CheckIp\IpNotFound;
use Lan\DTOs\Auth\Requests\CheckIpRequestDTO;
use Lan\DTOs\Auth\Responses\CheckIpResponseDTO;

class UserService implements UserServiceInterface
{
    public function __construct(
        private SecurityServiceInterface $securityService,
        private UserRepositoryInterface $userRepository,
    )
    {
    }

    public function logIn(LoginRequestDTO $requestDTO): LogInResultDTO
    {
        try{
            $securityResponse = $this->securityService->call('ebs_security_sign_in_account', [
                'account_type' => 'password',
                'username' => $requestDTO->getEmail(),
                'password' => $requestDTO->getPassword(),
            ]);

            $securityStatusCode = (int) $securityResponse['code'];

            if($securityStatusCode == 401){
                return new LogInResultDTO(
                    status: new AccountNotFoundError(),
                    user: UserResponseDTO::create(),
                );
            }

            if($securityStatusCode == 200){
                $subscriber = $this->securityService->getSubscriber();

                $user = $securityResponse['jwt']['data']['payload']['user'];
                $this->userRepository->markAppAsUsedByUser($user['id']);

                // todo: insert subscriber visit if( $security->getUser() )

                $userExpiredDate = $this->securityService->getUserExpiredDate();
                $this->securityService->getUser();

                return new LogInResultDTO(
                    status: new GenericSuccessResult(),
                    user: UserResponseDTO::create(
                        id: $user['id'],
                        xAuthToken: $securityResponse['jwt']['access_token'],
                        name: $user['surname'] . ' ' . $user['name'] . ' ' . $user['patronymic'],
                        email: $user['email'],
                        subscriber: $subscriber ? $subscriber->get('/name') : 'Пользователь не привязан к организации',
                        subscriptionEndDate: $userExpiredDate ? EbsCarbon::parse($userExpiredDate) : EbsCarbon::create(),
                    ),
                );
            }

            return new LogInResultDTO(
                status: new CustomError(
                    statusCode: (int) $securityResponse['code'],
                    message: $securityResponse['error'] ?: 'Авторизация не удалась'
                ),
                user: UserResponseDTO::create(),
            );
        } catch (Security_User_NotFound $e){
            return new LogInResultDTO(
                status: new AccountNotFoundError(),
                user: UserResponseDTO::create(),
            );
        }
    }

    public function logOut(): StatusInterface
    {
        $securityResponse = $this->securityService->call('ebs_security_sign_out');
        if((int) $securityResponse['code'] == 200){
            return new GenericSuccessResult();
        }

        if(isset($securityResponse['code']) && isset($securityResponse['error']) ){
            return new CustomError(
                statusCode: (int) $securityResponse['code'],
                message: $securityResponse['error']
            );
        }

        return LogOutError::create();
    }

    public function recoverPassword(RecoverPasswordRequestDTO $requestDTO): StatusInterface
    {
        $securityResponse = $this->securityService->call('security_password_reset_email', [
            'email' => $requestDTO->getEmail(),
        ]);

        if((int) $securityResponse['code'] == 200){
            return new GenericSuccessResult();
        }

        return new CustomError(
            statusCode: 400,
            message: $securityResponse['error'] ?: 'Запрос на воосстановление не отправлен'
        );
    }

    public function getSubscriberFromIp(CheckIpRequestDTO $requestDTO): CheckIpResponseDTO
    {
        $subscriber = $this->userRepository->getSubscriberFromIp($requestDTO->getIpAddress());
        if(!$subscriber->getPk()){
            return CheckIpResponseDTO::create(status: new IpNotFound());
        }

        return CheckIpResponseDTO::create(
            status: new GenericSuccessResult(),
            subscriberName: $subscriber->get('/name'),
        );
    }
}
